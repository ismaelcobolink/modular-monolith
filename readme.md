# An√°lisis de Arquitectura - Evently Modular Monolith

## üìã Resumen Ejecutivo

**Evently** es una aplicaci√≥n de gesti√≥n de eventos construida con .NET 9 que implementa una **arquitectura monol√≠tica modular**. Este enfoque combina las ventajas de un monolito (simplicidad de despliegue, transacciones locales) con la modularidad de los microservicios (separaci√≥n de dominios, mantenibilidad, escalabilidad futura).

### Caracter√≠sticas Principales
- **Framework**: .NET 9 con ASP.NET Core Minimal APIs
- **Base de Datos**: PostgreSQL con Entity Framework Core
- **Patrones**: CQRS, Domain-Driven Design (DDD), Clean Architecture
- **Mensajer√≠a**: MediatR para comunicaci√≥n interna, MassTransit para eventos de integraci√≥n
- **Logging**: Serilog con Seq
- **Containerizaci√≥n**: Docker y Docker Compose

## üèóÔ∏è Arquitectura General

### Estructura Modular

El sistema est√° dividido en tres m√≥dulos principales de negocio:

```
src/
‚îú‚îÄ‚îÄ Modules/
‚îÇ   ‚îú‚îÄ‚îÄ Events/        # Gesti√≥n de eventos
‚îÇ   ‚îú‚îÄ‚îÄ Ticketing/     # Sistema de tickets
‚îÇ   ‚îî‚îÄ‚îÄ Users/         # Gesti√≥n de usuarios
‚îú‚îÄ‚îÄ Common/            # C√≥digo compartido
‚îî‚îÄ‚îÄ API/              # API Gateway / Host
```

### Capas por M√≥dulo

Cada m√≥dulo sigue una arquitectura limpia (Clean Architecture) con 4 capas bien definidas:

```
M√≥dulo/
‚îú‚îÄ‚îÄ Domain/           # Entidades, Value Objects, Domain Events
‚îú‚îÄ‚îÄ Application/      # Casos de uso, Commands, Queries, Handlers
‚îú‚îÄ‚îÄ Infrastructure/   # Implementaciones t√©cnicas (DB, servicios externos)
‚îî‚îÄ‚îÄ Presentation/     # Endpoints HTTP, DTOs de entrada/salida
```

## üîç An√°lisis Detallado por Capa

### 1. **Capa de Dominio (Domain)**

La capa m√°s interna que contiene la l√≥gica de negocio pura:

- **Entidades**: Clases que representan conceptos del negocio (Event, Category, TicketType, User)
- **Value Objects**: Objetos inmutables sin identidad propia
- **Domain Events**: Eventos que ocurren en el dominio (EventPublished, TicketTypeCreated)
- **Interfaces de Repositorios**: Contratos para persistencia (IEventRepository, ICategoryRepository)
- **Errores de Dominio**: Definici√≥n de errores espec√≠ficos del negocio

**Ejemplo de Entidad**:
```csharp
public sealed class Event : Entity
{
    public Guid Id { get; private set; }
    public string Title { get; private set; }
    public EventStatus Status { get; private set; }
    
    public static Result<Event> Create(Category category, string title, ...)
    {
        // L√≥gica de validaci√≥n y creaci√≥n
    }
    
    public Result Publish()
    {
        // L√≥gica de negocio para publicar
    }
}
```

### 2. **Capa de Aplicaci√≥n (Application)**

Orquesta los casos de uso del sistema:

- **Commands/Queries**: Implementaci√≥n del patr√≥n CQRS
  - Commands: CreateEventCommand, PublishEventCommand, CancelEventCommand
  - Queries: GetEventQuery, SearchEventsQuery
- **Handlers**: Procesadores de comandos y consultas usando MediatR
- **Validators**: Validaci√≥n de entrada con FluentValidation
- **DTOs**: Objetos de transferencia entre capas
- **Behaviors**: Pipeline behaviors para cross-cutting concerns (logging, validaci√≥n)

**Patr√≥n CQRS implementado**:
```csharp
// Command
public record PublishEventCommand(Guid EventId) : ICommand;

// Handler
public class PublishEventCommandHandler : ICommandHandler<PublishEventCommand>
{
    public async Task<Result> Handle(PublishEventCommand command, CancellationToken ct)
    {
        // L√≥gica del caso de uso
    }
}
```

### 3. **Capa de Infraestructura (Infrastructure)**

Implementaciones t√©cnicas y acceso a recursos externos:

- **DbContext**: Configuraci√≥n de Entity Framework Core
- **Repositories**: Implementaci√≥n concreta de los repositorios
- **Migrations**: Migraciones de base de datos
- **Configuraci√≥n de Entidades**: Mapeo OR/M con Fluent API
- **Servicios de Integraci√≥n**: Publicaci√≥n de eventos con MassTransit
- **Interceptors**: Para auditor√≠a y funcionalidades transversales

**Caracter√≠sticas t√©cnicas**:
- Uso del patr√≥n Outbox para garantizar consistencia en eventos
- Interceptores para publicaci√≥n autom√°tica de domain events
- Configuraci√≥n modular de DbContext por m√≥dulo

### 4. **Capa de Presentaci√≥n (Presentation)**

Expone la funcionalidad a trav√©s de HTTP:

- **Endpoints**: Minimal APIs organizadas por feature
- **Request/Response DTOs**: Contratos de la API
- **Mapeo**: Conversi√≥n entre DTOs y comandos/queries
- **Validaci√≥n**: Validaci√≥n de entrada en endpoints

**Ejemplo de Endpoint**:
```csharp
app.MapPut("events/{id}/publish", async (Guid id, ISender sender) =>
{
    Result result = await sender.Send(new PublishEventCommand(id));
    return result.Match(Results.NoContent, ApiResults.Problem);
});
```

## üîÑ Flujo de Comunicaci√≥n

### Flujo t√≠pico de una petici√≥n:

1. **Cliente HTTP** ‚Üí Realiza petici√≥n a la API
2. **Minimal API Endpoint** ‚Üí Recibe y valida la petici√≥n
3. **MediatR** ‚Üí Enruta el comando/query al handler apropiado
4. **Application Handler** ‚Üí Ejecuta la l√≥gica del caso de uso
5. **Domain** ‚Üí Aplica reglas de negocio
6. **Repository** ‚Üí Persiste cambios si es necesario
7. **Domain Events** ‚Üí Se publican eventos del dominio
8. **Response** ‚Üí Se devuelve resultado al cliente

### Comunicaci√≥n entre M√≥dulos con MassTransit

Los m√≥dulos se comunican de manera **as√≠ncrona y desacoplada** utilizando **eventos de integraci√≥n** implementados con **MassTransit**. Esta arquitectura garantiza que los m√≥dulos permanezcan independientes mientras pueden reaccionar a cambios en otros m√≥dulos.

#### üîå Arquitectura de Eventos de Integraci√≥n

**1. Configuraci√≥n de MassTransit**

La configuraci√≥n central se realiza en `InfrastructureConfiguration`:

```csharp
public static IServiceCollection AddInfrastructure(
    this IServiceCollection services,
    Action<IRegistrationConfigurator>[] configureConsumers,
    string databaseConnectionString)
{
    // Configuraci√≥n de MassTransit
    services.AddMassTransit(configure =>
    {
        configure.SetKebabCaseEndpointNameFormatter();
        
        // Registro din√°mico de consumers desde cada m√≥dulo
        foreach (Action<IRegistrationConfigurator> consumer in configureConsumers)
        {
            consumer(configure);
        }
        
        // Usando transporte en memoria (puede cambiarse a RabbitMQ, Azure Service Bus, etc.)
        configure.UsingInMemory((context, cfg) =>
        {
            cfg.ConfigureEndpoints(context);
        });
    });
}
```

**2. Publicaci√≥n de Eventos**

El sistema implementa un **EventBus** que encapsula MassTransit:

```csharp
internal sealed class EventBus(IBus bus) : IEventBus
{
    public async Task PublishAsync<T>(T integrationEvent, CancellationToken cancellationToken) 
        where T : IntegrationEvent
    {
        await _bus.Publish(integrationEvent, cancellationToken);
    }
}
```

**3. Flujo de Eventos: Domain ‚Üí Integration**

Los eventos siguen este flujo:
1. **Domain Event** se genera en la entidad
2. **Domain Event Handler** procesa el evento interno
3. **Integration Event** se publica para otros m√≥dulos

#### üì® Ejemplo Concreto: Registro de Usuario

Este es el flujo completo implementado actualmente en el sistema:

**1. M√≥dulo Users - Publicaci√≥n del Evento**

Cuando un usuario se registra:

```csharp
// 1. El comando RegisterUserCommand crea un nuevo usuario
public class RegisterUserCommandHandler
{
    public async Task<Result<Guid>> Handle(RegisterUserCommand command)
    {
        var user = User.Create(email, firstName, lastName);
        // El usuario emite UserRegisteredDomainEvent
    }
}

// 2. El Domain Event Handler procesa el evento y publica Integration Event
internal sealed class RegisterUserDomainEventHandler(ISender sender, IEventBus eventBus) 
    : IDomainEventHandler<UserRegisteredDomainEvent>
{
    public async Task Handle(UserRegisteredDomainEvent notification, CancellationToken cancellationToken)
    {
        // Obtiene datos completos del usuario
        Result<UserResponse> result = await _sender.Send(
            new GetUserQuery(notification.UserId), 
            cancellationToken);
        
        // Publica evento de integraci√≥n para otros m√≥dulos
        await _eventBus.PublishAsync(
            new UserRegisteredIntegrationEvent(
                notification.Id,
                notification.OccurredOnUtc,
                notification.UserId,
                result.Value.Email,
                result.Value.FirstName,
                result.Value.LastName
            ), 
            cancellationToken);
    }
}
```

**2. Definici√≥n del Evento de Integraci√≥n**

Los eventos de integraci√≥n se definen en proyectos separados para evitar acoplamiento:

```csharp
// En Evently.Modules.Users.IntegrationEvents
public sealed class UserRegisteredIntegrationEvent : IntegrationEvent
{
    public Guid UserId { get; init; }
    public string Email { get; init; }
    public string FirstName { get; init; }
    public string LastName { get; init; }
}
```

**3. M√≥dulo Ticketing - Consumo del Evento**

El m√≥dulo de Ticketing necesita crear un Customer cuando se registra un usuario:

```csharp
// Consumer en la capa de Presentaci√≥n
public sealed class UserRegisteredIntegrationEventConsumer(ISender sender) 
    : IConsumer<UserRegisteredIntegrationEvent>
{
    public async Task Consume(ConsumeContext<UserRegisteredIntegrationEvent> context)
    {
        // Crea un Customer en el contexto de Ticketing
        Result result = await _sender.Send(
            new CreateCustomerCommand(
                context.Message.UserId, 
                context.Message.Email, 
                context.Message.FirstName, 
                context.Message.LastName));
        
        if (result.IsFailure)
        {
            throw new EventlyException(nameof(UserRegisteredIntegrationEventConsumer), result.Error);
        }
    }
}
```

**4. Registro del Consumer**

Cada m√≥dulo registra sus consumers:

```csharp
// En TicketingModule.cs
public static void ConfigureConsumers(IRegistrationConfigurator registrationConfiguration)
{
    registrationConfiguration.AddConsumer<UserRegisteredIntegrationEventConsumer>();
}
```

#### üîÑ Diagrama de Comunicaci√≥n entre M√≥dulos

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        Users Module                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  1. User.Create() ‚Üí UserRegisteredDomainEvent               ‚îÇ
‚îÇ  2. DomainEventHandler ‚Üí Procesa evento interno             ‚îÇ
‚îÇ  3. EventBus.PublishAsync(UserRegisteredIntegrationEvent)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ
                        ‚îÇ MassTransit In-Memory Bus
                        ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   UserRegisteredIntegration   ‚îÇ
        ‚îÇ          Event                ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ         Event Queue            ‚îÇ
    ‚îÇ      (In-Memory/RabbitMQ)      ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Ticketing Module                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  1. UserRegisteredIntegrationEventConsumer.Consume()        ‚îÇ
‚îÇ  2. CreateCustomerCommand ‚Üí Customer.Create()               ‚îÇ
‚îÇ  3. Persiste Customer en su propio contexto                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### üéØ Ventajas del Enfoque con MassTransit

1. **Desacoplamiento Total**: Los m√≥dulos no se conocen directamente
2. **Escalabilidad**: F√°cil migraci√≥n a bus externo (RabbitMQ, Azure Service Bus)
3. **Resiliencia**: Reintentos y pol√≠ticas de error configurables
4. **Observabilidad**: Logging y tracing integrado
5. **Testing**: F√°cil de testear con InMemory transport
6. **Flexibilidad**: Permite procesamiento as√≠ncrono y paralelo

#### üì¶ Organizaci√≥n de Eventos de Integraci√≥n

```
Modules/
‚îú‚îÄ‚îÄ Users/
‚îÇ   ‚îú‚îÄ‚îÄ *.Domain           (UserRegisteredDomainEvent)
‚îÇ   ‚îú‚îÄ‚îÄ *.Application       (RegisterUserDomainEventHandler)
‚îÇ   ‚îú‚îÄ‚îÄ *.IntegrationEvents (UserRegisteredIntegrationEvent) ‚Üê Proyecto separado
‚îÇ   ‚îî‚îÄ‚îÄ *.Infrastructure    (Configuraci√≥n del m√≥dulo)
‚îî‚îÄ‚îÄ Ticketing/
    ‚îú‚îÄ‚îÄ *.Domain           (Customer entity)
    ‚îú‚îÄ‚îÄ *.Application      (CreateCustomerCommand)
    ‚îî‚îÄ‚îÄ *.Presentation     (UserRegisteredIntegrationEventConsumer)
```

#### üîÆ Posibles Eventos de Integraci√≥n Futuros

Bas√°ndose en la arquitectura actual, estos ser√≠an eventos naturales a implementar:

**Desde Events Module:**
- `EventPublishedIntegrationEvent` ‚Üí Ticketing crea inventario de tickets
- `EventCancelledIntegrationEvent` ‚Üí Ticketing cancela tickets vendidos
- `TicketTypeCreatedIntegrationEvent` ‚Üí Ticketing actualiza configuraci√≥n

**Desde Ticketing Module:**
- `TicketPurchasedIntegrationEvent` ‚Üí Events actualiza disponibilidad
- `PaymentProcessedIntegrationEvent` ‚Üí Users actualiza historial

**Desde Users Module:**
- `UserProfileUpdatedIntegrationEvent` ‚Üí Ticketing actualiza Customer
- `UserDeletedIntegrationEvent` ‚Üí Soft delete en todos los m√≥dulos

#### ‚öôÔ∏è Configuraci√≥n para Producci√≥n

Para ambientes productivos, se puede cambiar f√°cilmente el transporte:

```csharp
// Cambiar de InMemory a RabbitMQ
configure.UsingRabbitMq((context, cfg) =>
{
    cfg.Host("rabbitmq://localhost", h =>
    {
        h.Username("guest");
        h.Password("guest");
    });
    
    cfg.ConfigureEndpoints(context);
});
```

Esta arquitectura proporciona una base s√≥lida para la comunicaci√≥n entre m√≥dulos, manteniendo el bajo acoplamiento y permitiendo una f√°cil evoluci√≥n hacia microservicios si fuera necesario.

## üõ†Ô∏è Tecnolog√≠as y Patrones

### Stack Tecnol√≥gico
- **.NET 9**: Framework principal
- **PostgreSQL**: Base de datos relacional
- **Entity Framework Core**: ORM
- **MediatR**: Implementaci√≥n del patr√≥n Mediator
- **FluentValidation**: Validaci√≥n de datos
- **MassTransit**: Bus de mensajes para eventos de integraci√≥n
- **Serilog + Seq**: Logging estructurado
- **Docker**: Containerizaci√≥n

### Patrones Implementados
- **Domain-Driven Design (DDD)**: Modelado del dominio
- **CQRS**: Separaci√≥n de comandos y consultas
- **Repository Pattern**: Abstracci√≥n de acceso a datos
- **Unit of Work**: Gesti√≥n de transacciones
- **Outbox Pattern**: Garant√≠a de entrega de eventos
- **Result Pattern**: Manejo expl√≠cito de errores sin excepciones
- **Specification Pattern**: Para queries complejas

## üöÄ Ventajas de esta Arquitectura

1. **Modularidad**: Cada m√≥dulo es independiente y puede evolucionar por separado
2. **Escalabilidad**: F√°cil transici√≥n a microservicios si es necesario
3. **Mantenibilidad**: Separaci√≥n clara de responsabilidades
4. **Testabilidad**: Cada capa puede testearse de forma aislada
5. **Simplicidad operacional**: Un solo despliegue, una sola base de datos
6. **Transacciones ACID**: Al ser un monolito, mantiene transacciones locales
7. **Desarrollo r√°pido**: No hay overhead de comunicaci√≥n entre servicios

## üì¶ Estructura de Proyectos

```
Evently.sln
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ API/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Evently.Api                    # Host principal de la aplicaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ Common/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Evently.Common.Domain          # Clases base del dominio
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Evently.Common.Application     # Utilidades de aplicaci√≥n
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Evently.Common.Infrastructure  # Configuraci√≥n base de infra
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Evently.Common.Presentation    # Utilidades para endpoints
‚îÇ   ‚îî‚îÄ‚îÄ Modules/
‚îÇ       ‚îú‚îÄ‚îÄ Events/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ *.Domain
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ *.Application
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ *.Infrastructure
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ *.Presentation
‚îÇ       ‚îú‚îÄ‚îÄ Ticketing/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ [misma estructura]
‚îÇ       ‚îî‚îÄ‚îÄ Users/
‚îÇ           ‚îî‚îÄ‚îÄ [misma estructura]
‚îî‚îÄ‚îÄ docker-compose.yml                      # Orquestaci√≥n de contenedores
```

## üîß Configuraci√≥n y Extensibilidad

### Configuraci√≥n Modular
Cada m√≥dulo tiene su propia configuraci√≥n:
- `modules.events.json`
- `modules.ticketing.json`
- `modules.users.json`

### Registro de M√≥dulos
```csharp
builder.Services.AddEventsModule(configuration);
builder.Services.AddUsersModule(configuration);
builder.Services.AddTicketingModule(configuration);
```

### Pipeline de MediatR
Comportamientos configurables para:
- Logging de comandos/queries
- Validaci√≥n autom√°tica
- Gesti√≥n de transacciones
- Manejo de errores

## üê≥ Infraestructura con Docker

El proyecto incluye configuraci√≥n completa de Docker:

- **API**: Contenedor principal de la aplicaci√≥n
- **PostgreSQL**: Base de datos
- **Seq**: Servidor de logs

## üìä Diagrama de Arquitectura

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   Cliente HTTP                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              API Gateway (Minimal APIs)             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    MediatR                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ              ‚îÇ              ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Events      ‚îÇ  ‚îÇ Ticketing    ‚îÇ  ‚îÇ   Users      ‚îÇ
‚îÇ  Module      ‚îÇ  ‚îÇ  Module      ‚îÇ  ‚îÇ  Module      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇPresentation  ‚îÇ  ‚îÇPresentation  ‚îÇ  ‚îÇPresentation  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇApplication   ‚îÇ  ‚îÇApplication   ‚îÇ  ‚îÇApplication   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Domain      ‚îÇ  ‚îÇ  Domain      ‚îÇ  ‚îÇ  Domain      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇInfrastructure‚îÇ  ‚îÇInfrastructure‚îÇ  ‚îÇInfrastructure‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ                 ‚îÇ                 ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îê
‚îÇ            PostgreSQL Database             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üéØ Casos de Uso Principales

### M√≥dulo de Eventos
- Crear evento
- Publicar evento
- Cancelar evento
- Reprogramar evento
- Buscar eventos
- Gestionar categor√≠as
- Definir tipos de tickets

### M√≥dulo de Ticketing
- Comprar tickets
- Validar disponibilidad
- Gestionar inventario
- Procesar pagos

### M√≥dulo de Usuarios
- Registro de usuarios
- Autenticaci√≥n
- Gesti√≥n de perfiles
- Autorizaci√≥n

## üîê Consideraciones de Seguridad

- Validaci√≥n en m√∫ltiples capas
- Uso del patr√≥n Result para evitar excepciones
- Sanitizaci√≥n de inputs con FluentValidation
- Logging estructurado para auditor√≠a
- Segregaci√≥n de responsabilidades por m√≥dulo

## üö¶ Como iniciar el proyecto

1. Instalar .NET 9 SDK desde https://dotnet.microsoft.com/en-us/download/dotnet/9.0
2. Instalar PostgreSQL desde https://www.postgresql.org/download/
3. Instalar Docker desde https://www.docker.com/get-started/
4. Clonar el repositorio del proyecto
5. Escribir en la terminal:

```bash
docker-compose up
```

5.1. Si falla la imagen usad los siguientes comandos:
```bash
docker-compose down
docker-compose build --no-cache
docker-compose up
```

6. Url de la API: https://localhost:5001
6.1. Si usais Swagger: https://localhost:5001/swagger/index.html
